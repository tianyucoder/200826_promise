<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Promise的API</title>
</head>
<body>
  <!-- 
    1. Promise构造函数: new Promise (executor) {}
					executor函数: 是同步执行的，(resolve, reject) => {}
					resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。
					reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。
					说明: excutor函数会在Promise内部立即同步调用,异步代码放在excutor函数中。

    2. Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)
					onFulfilled: 成功的回调函数 (value) => {}
					onRejected: 失败的回调函数 (reason) => {}
					特别注意(难点)：then方法会返回一个新的Promise实例对象

    3. Promise.prototype.catch方法: Promise实例.catch(onRejected)
          onRejected: 失败的回调函数 (reason) => {}
          说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected)

    4. Promise.resolve方法: Promise.resolve(value)
          说明: 用于快速返回一个状态为fulfilled的Promise实例对象

		5. Promise.reject方法: Promise.reject方法(reason)
          说明: 用于快速返回一个状态为rejected的Promise实例对象
		
    6. Promise.all方法: Promise.all(promiseArr)
          promiseArr: 包含n个Promise实例的数组
          说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。
				
    7. Promise.race方法: Promise.race(promiseArr)
          promiseArr: 包含n个Promise实例的数组
          说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。
	-->
	<script type="text/javascript" >

	//验证：then方法会返回一个新的Promise实例对象。(暂且不研究返回的这个新Promise实例状态怎么变化)
	//#region 
	/* const p = new Promise((resolve,reject)=>{
		setTimeout(()=>{
			resolve(100)
		},1000)
	})
	const x = p.then(
		value => {console.log('成功了',value);},
		reason =>{console.log('失败了',reason);}
	)
	console.log('50'); */
	//#endregion

	//Promise.prototype.catch方法
	const p = new Promise((resolve,reject)=>{
		setTimeout(()=>{
			resolve(100)
		},1000)
	})

	p.then(
		undefined,
		reason => {console.log('失败了1',reason);}
	)

	p.catch(
		reason => {console.log('失败了2',reason);}
	)

	</script>
</body>
</html>